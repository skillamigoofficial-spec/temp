{
  "OpenMP Fibonacci Program": {
    "scope": "java",
    "prefix": "b_fibo_omp",
    "body": [
      "//fibonaci  using openmp//",
      "",
      "#include <bits/stdc++.h>",
      "#include <omp.h>",
      "using namespace std;",
      "",
      "long long fib_seq(int n) {",
      "    if (n < 2) return n;",
      "    return fib_seq(n - 1) + fib_seq(n - 2);",
      "}",
      "",
      "long long fib_task(int n) {",
      "    if (n < 2) return n;",
      "    long long x, y;",
      "    #pragma omp task shared(x)",
      "    {x = fib_task(n - 1);}",
      "    #pragma omp task shared(y)",
      "    {y = fib_task(n - 2);}",
      "    #pragma omp taskwait",
      "    return x + y;",
      "}",
      "",
      "int main() {",
      "    int N = 20;",
      "    long long result_seq, result_par;",
      "    double start, end, time_seq, time_par;",
      "",
      "    start = omp_get_wtime();",
      "    result_seq = fib_seq(N);",
      "    cout<<omp_get_num_threads();",
      "    end = omp_get_wtime();",
      "    time_seq = end - start;",
      "    cout << \"Sequential Fibonacci(\" << N << \") = \" << result_seq << endl;",
      "    cout << \"Sequential time = \" << time_seq << \" seconds\\n\" << endl;",
      "",
      "    start = omp_get_wtime();",
      "    #pragma omp parallel",
      "    {",
      "        #pragma omp single",
      "        result_par = fib_task(N);",
      "    }",
      "    end = omp_get_wtime();",
      "    time_par = end - start;",
      "    cout << \"Parallel Fibonacci(\" << N << \") = \" << result_par << endl;",
      "    cout << \"Parallel time = \" << time_par << \" seconds\\n\" << endl;",
      "",
      "    cout << \"Speedup = \" << time_seq / time_par << endl;",
      "    return 0;",
      "}"
    ],
    "description": ""
  },

  "OpenMP Matrix Multiplication": {
    "scope": "java",
    "prefix": "b_matrix_omp",
    "body": [
      "/*matrix multiplication*(openmp)*/",
      "",
      "#include <bits/stdc++.h>",
      "#include <omp.h>",
      "using namespace std;",
      "",
      "int main() {",
      "    int r1 = 3, c1 = 3, r2 = 3, c2 = 3;",
      "",
      "    if (c1 != r2) {",
      "        cout << \"Matrix multiplication not possible!\\\\n\";",
      "        return 0;",
      "    }",
      "",
      "    vector<vector<int>> m1{",
      "        {1, 0, 1},",
      "        {0, 1, 0},",
      "        {1, 1, 0}",
      "    };",
      "",
      "    vector<vector<int>> m2{",
      "        {1, 1, 0},",
      "        {0, 1, 0},",
      "        {1, 0, 1}",
      "    };",
      "",
      "    vector<vector<int>> result_parallel(3, vector<int>(3, 0));",
      "    vector<vector<int>> result_serial(3, vector<int>(3, 0));",
      "",
      "    // ===== Serial multiplication =====",
      "    double start_serial = omp_get_wtime();",
      "    for (int i = 0; i < r1; i++) {",
      "        for (int j = 0; j < c2; j++) {",
      "            for (int k = 0; k < c1; k++) {",
      "                result_serial[i][j] += m1[i][k] * m2[k][j];",
      "            }",
      "        }",
      "    }",
      "    double end_serial = omp_get_wtime();",
      "    double serial_time = end_serial - start_serial;",
      "    cout << \"Serial time: \" << serial_time << \" seconds\\\\n\";",
      "",
      "    // ===== Parallel multiplication =====",
      "    double start_parallel = omp_get_wtime();",
      "    #pragma omp parallel for collapse(2)",
      "    for (int i = 0; i < r1; i++) {",
      "        for (int j = 0; j < c2; j++) {",
      "            for (int k = 0; k < c1; k++) {",
      "                result_parallel[i][j] += m1[i][k] * m2[k][j];",
      "            }",
      "        }",
      "    }",
      "    double end_parallel = omp_get_wtime();",
      "    double parallel_time = end_parallel - start_parallel;",
      "    cout << \"Parallel time: \" << parallel_time << \" seconds\\\\n\";",
      "",
      "    // ===== Speedup =====",
      "    double speedup = serial_time / parallel_time;",
      "    cout << \"Speedup: \" << speedup << endl;",
      "",
      "    // ===== Output Result =====",
      "    cout << \"\\\\nResultant Matrix:\\\\n\";",
      "    for (int i = 0; i < 3; i++) {",
      "        for (int j = 0; j < 3; j++) {",
      "            cout << result_parallel[i][j] << \" \";",
      "        }",
      "        cout << endl;",
      "    }",
      "",
      "    return 0;",
      "}"
    ],
    "description": ""
  },

  "MPI Sieve Program": {
    "scope": "java",
    "prefix": "b_sieve_mpi",
    "body": [
      "#include <bits/stdc++.h>",
      "#include <mpi.h>",
      "using namespace std;",
      "",
      "bool is_prime(int n) {",
      "    if (n < 2) return false;",
      "    for (int i = 2; i * i <= n; i++)",
      "        if (n % i == 0) return false;",
      "    return true;",
      "}",
      "",
      "int main(int argc, char** argv) {",
      "    MPI_Init(&argc, &argv);",
      "",
      "    int rank, size;",
      "    MPI_Comm_rank(MPI_COMM_WORLD, &rank);",
      "    MPI_Comm_size(MPI_COMM_WORLD, &size);",
      "",
      "    int N = 50;",
      "",
      "    int chunk = N / size;",
      "    int start = rank * chunk + 2;",
      "    int end = (rank == size - 1) ? N : start + chunk - 1;",
      "",
      "    vector<int> local_primes;",
      "    for (int i = start; i <= end; i++)",
      "        if (is_prime(i)) local_primes.push_back(i);",
      "",
      "    MPI_Barrier(MPI_COMM_WORLD);",
      "    for (int p = 0; p < size; p++) {",
      "        if (p == rank) {",
      "            cout << \"Process \" << rank << \" primes: \";",
      "            for (int num : local_primes) cout << num << \" \";",
      "            cout << endl;",
      "        }",
      "        MPI_Barrier(MPI_COMM_WORLD);",
      "    }",
      "",
      "    MPI_Finalize();",
      "    return 0;",
      "}"
    ],
    "description": ""
  }
,
  "OpenMP Sieve Program": {
    "scope": "java",
    "prefix": "b_sieve_omp",
    "body": [
      "#include <bits/stdc++.h>",
      "#include <omp.h>",
      "using namespace std;",
      "",
      "int main() {",
      "    cout << \"Enter x: \";",
      "    int x;",
      "    cin >> x;",
      "",
      "    vector<bool> is_prime(x + 1, true);",
      "    is_prime[0] = is_prime[1] = false;",
      "",
      "    for (int i = 2; i * i <= x; i++) {",
      "        if (is_prime[i]) {",
      "            #pragma omp parallel for",
      "            for (int j = i * i; j <= x; j += i) {",
      "                is_prime[j] = false;",
      "            }",
      "        }",
      "    }",
      "",
      "    for (int i = 0; i <= x; i++) {",
      "        if (is_prime[i]) cout << i << \" \";",
      "    }",
      "    cout << \"\\\\n\";",
      "}"
    ],
    "description": ""
  }
,
  "MonteCarloPiMPI": {
    "scope": "java",
    "prefix": "b_monte_mpi",
    "body": [
      "#include <iostream>",
      "#include <cstdlib>",
      "#include <ctime>",
      "#include <mpi.h>",
      "using namespace std;",
      "",
      "int main(int argc, char** argv) {",
      "    MPI_Init(&argc, &argv);",
      "",
      "    int rank, size;",
      "    MPI_Comm_rank(MPI_COMM_WORLD, &rank);",
      "    MPI_Comm_size(MPI_COMM_WORLD, &size);",
      "",
      "    long long n = 1000000;",
      "    long long local_n = n / size;",
      "    long long local_count = 0;",
      "",
      "    srand(time(0) + rank);",
      "",
      "    for (long long i = 0; i < local_n; i++) {",
      "        double x = (double)rand() / RAND_MAX;",
      "        double y = (double)rand() / RAND_MAX;",
      "        if (x * x + y * y <= 1.0)",
      "            local_count++;",
      "    }",
      "",
      "    long long total_count = 0;",
      "    MPI_Reduce(&local_count, &total_count, 1, MPI_LONG_LONG, MPI_SUM, 0, MPI_COMM_WORLD);",
      "",
      "    if (rank == 0) {",
      "        double pi = 4.0 * total_count / n;",
      "        cout << \"Estimated Pi = \" << pi << endl;",
      "    }",
      "",
      "    MPI_Finalize();",
      "    return 0;",
      "}"
    ],
    "description": "C++ Monte Carlo Method to Estimate Pi using MPI (no comments, Java snippet scope)"
  }
,
  "MonteCarloPiOpenMP": {
    "scope": "java",
    "prefix": "b_monte_omp",
    "body": [
      "#include<bits/stdc++.h>",
      "#include <omp.h>",
      "using namespace std;",
      "",
      "int main() {",
      "    long long n = 1000000;",
      "    long long count = 0;",
      "",
      "    double start = omp_get_wtime();",
      "",
      "    #pragma omp parallel for reduction(+:count)",
      "    for (long long i = 0; i < n; i++) {",
      "        double x = (double)rand() / RAND_MAX;",
      "        double y = (double)rand() / RAND_MAX;",
      "        if (x * x + y * y <= 1.0)",
      "            count++;",
      "    }",
      "",
      "    double pi = 4.0 * count / n;",
      "    double end = omp_get_wtime();",
      "",
      "    cout << \"Estimated Pi = \" << pi << endl;",
      "    cout << \"Time taken = \" << end - start << \" seconds\" << endl;",
      "",
      "    return 0;",
      "}"
    ],
    "description": ""
  }
,
  "PiEstimationOpenMP": {
    "scope": "java",
    "prefix": "b_pi_omp",
    "body": [
      "#include <bits/stdc++.h>",
      "#include <omp.h>",
      "using namespace std;",
      "",
      "int main() {",
      "    long long n = 100000000;",
      "    double step = 1.0 / n;",
      "    double pi = 0.0;",
      "",
      "    double start = omp_get_wtime();",
      "    #pragma omp parallel for reduction(+:pi)",
      "    for(long long i = 0; i < n; i++) {",
      "        double x = (i + 0.5) * step;",
      "        pi += 4.0 / (1.0 + x * x);",
      "    }",
      "    pi *= step;",
      "    double end = omp_get_wtime();",
      "",
      "    cout << \"Pi = \" << fixed << setprecision(12) << pi << endl;",
      "    cout << \"Time = \" << end - start << \" sec\" << endl;",
      "}"
    ],
    "description": ""
  }
,
  "PiEstimationMPI": {
    "scope": "java",
    "prefix": "b_pi_mpi",
    "body": [
      "#include <mpi.h>",
      "#include <bits/stdc++.h>",
      "using namespace std;",
      "",
      "int main(int argc, char** argv) {",
      "    MPI_Init(&argc, &argv);",
      "",
      "    int rank, size;",
      "    MPI_Comm_rank(MPI_COMM_WORLD, &rank);",
      "    MPI_Comm_size(MPI_COMM_WORLD, &size);",
      "",
      "    long long n = 10000000;",
      "    double step = 1.0 / n;",
      "    double local_sum = 0.0;",
      "",
      "    for (long long i = rank; i < n; i += size) {",
      "        double x = (i + 0.5) * step;",
      "        local_sum += 4.0 / (1.0 + x * x);",
      "    }",
      "",
      "    double global_sum = 0.0;",
      "",
      "    MPI_Reduce(&local_sum, &global_sum, 1, MPI_DOUBLE, MPI_SUM, 0, MPI_COMM_WORLD);",
      "",
      "    if (rank == 0) {",
      "        double pi = step * global_sum;",
      "        cout << setprecision(15) << \"Calculated Pi = \" << pi << endl;",
      "    }",
      "",
      "    MPI_Finalize();",
      "    return 0;",
      "}"
    ],
    "description": ""
  }
,
  "LUFactorizationOpenMP": {
    "scope": "java",
    "prefix": "b_LU_omp",
    "body": [
      "#include <bits/stdc++.h>",
      "#include <omp.h>",
      "using namespace std;",
      "",
      "#define N 4",
      "",
      "void printMatrix(double M[N][N], const string &name) {",
      "    cout << name << \" = \\n\";",
      "    for (int i = 0; i < N; i++) {",
      "        for (int j = 0; j < N; j++)",
      "            cout << setw(8) << fixed << setprecision(4) << M[i][j] << \" \";",
      "        cout << endl;",
      "    }",
      "    cout << endl;",
      "}",
      "",
      "int main() {",
      "    double A[N][N] = {",
      "        {4, 3, 2, 1},",
      "        {3, 3, 2, 1},",
      "        {2, 2, 2, 1},",
      "        {1, 1, 1, 1}",
      "    };",
      "    double L[N][N] = {0};",
      "    double U[N][N] = {0};",
      "",
      "    double start = omp_get_wtime();",
      "",
      "    for (int i = 0; i < N; i++) {",
      "        #pragma omp parallel for",
      "        for (int j = i; j < N; j++) {",
      "            double sum = 0.0;",
      "            for (int k = 0; k < i; k++) sum += L[i][k] * U[k][j];",
      "            U[i][j] = A[i][j] - sum;",
      "        }",
      "",
      "        #pragma omp parallel for",
      "        for (int j = i; j < N; j++) {",
      "            if (i == j) L[i][i] = 1.0;",
      "            else {",
      "                double sum = 0.0;",
      "                for (int k = 0; k < i; k++) sum += L[j][k] * U[k][i];",
      "                L[j][i] = (A[j][i] - sum) / U[i][i];",
      "            }",
      "        }",
      "    }",
      "",
      "    double end = omp_get_wtime();",
      "    printMatrix(L, \"L\");",
      "    printMatrix(U, \"U\");",
      "    cout << \"Execution time = \" << end - start << \" seconds\" << endl;",
      "",
      "    return 0;",
      "}"
    ],
    "description": ""
  }
,
  "ParallelOddEvenBubbleSort": {
    "scope": "java",
    "prefix": "b_odd_even_omp",
    "body": [
      "#include<bits/stdc++.h>",
      "#include <omp.h>",
      "using namespace std;",
      "",
      "void parallelBubbleSort(vector<int>& arr) {",
      "    int n = arr.size();",
      "    for (int i = 0; i < n; i++) {",
      "        if (i % 2 == 0) {",
      "            #pragma omp parallel for",
      "            for (int j = 0; j < n - 1; j += 2) {",
      "                if (arr[j] > arr[j + 1])",
      "                    swap(arr[j], arr[j + 1]);",
      "            }",
      "        } else {",
      "            #pragma omp parallel for",
      "            for (int j = 1; j < n - 1; j += 2) {",
      "                if (arr[j] > arr[j + 1])",
      "                    swap(arr[j], arr[j + 1]);",
      "            }",
      "        }",
      "    }",
      "}",
      "",
      "int main() {",
      "    int n = 10;",
      "    vector<int> a(n), b(n);",
      "    for (int i = 0; i < n; i++) {",
      "        a[i] = rand() % 10000;",
      "        b[i] = a[i];",
      "    }",
      "",
      "    double start_parallel = omp_get_wtime();",
      "    parallelBubbleSort(b);",
      "    double end_parallel = omp_get_wtime();",
      "",
      "    double t_parallel = end_parallel - start_parallel;",
      "",
      "    cout << \"Parallel Time: \" << t_parallel << \" s\\n\";",
      "    for(int i=0;i<n;i++){",
      "        cout<<b[i]<<\" \";",
      "    }",
      "    cout<<endl;",
      "",
      "    return 0;",
      "}"
    ],
    "description": ""
  },

  "ParallelBubbleSort": {
    "scope": "java",
    "prefix": "b_bubble_omp",
    "body": [
      "#include <bits/stdc++.h>",
      "#include <omp.h>",
      "using namespace std;",
      "",
      "void bubbleSort(vector<int>& arr) {",
      "    int n = arr.size();",
      "    for (int i = 0; i < n - 1; i++) {",
      "        #pragma omp parallel for",
      "        for (int j = 0; j < n - i - 1; j++) {",
      "            if (arr[j] > arr[j + 1]) swap(arr[j], arr[j + 1]);",
      "        }",
      "    }",
      "}",
      "",
      "int main() {",
      "    vector<int> arr = {34, 7, 23, 32, 5, 62, 32, 12, 22, 9};",
      "    double start = omp_get_wtime();",
      "    bubbleSort(arr);",
      "    double end = omp_get_wtime();",
      "    cout << \"Bubble Sorted Array: \";",
      "    for (auto x : arr) cout << x << \" \";",
      "    cout << \"\\nBubble Sort Time: \" << end - start << \" seconds\\n\";",
      "    return 0;",
      "}"
    ],
    "description": ""
  }
,
    
    "QuickSort Parallel OpenMP": {
        "prefix": "b_quick_omp",
        "scope": "java",

        "body": [

            "#include <bits/stdc++.h>",
            "#include <omp.h>",
            "using namespace std;",
            "",
            "int partition(vector<int> &arr, int low, int high) {",
            "    int pivot = arr[high];",
            "    int i = low - 1;",
            "    for (int j = low; j < high; j++) {",
            "        if (arr[j] < pivot) {",
            "            i++;",
            "            swap(arr[i], arr[j]);",
            "        }",
            "    }",
            "    swap(arr[i + 1], arr[high]);",
            "    return i + 1;",
            "}",
            "",
            "void quickSort(vector<int> &arr, int low, int high) {",
            "    if (low < high) {",
            "        int pi = partition(arr, low, high);",
            "        #pragma omp parallel sections",
            "        {",
            "            #pragma omp section",
            "            quickSort(arr, low, pi - 1);",
            "",
            "            #pragma omp section",
            "            quickSort(arr, pi + 1, high);",
            "        }",
            "    }",
            "}",
            "",
            "int main() {",
            "    vector<int> arr = {34, 7, 23, 32, 5, 62, 32, 12, 22, 9};",
            "    double start, end;",
            "    start = omp_get_wtime();",
            "    quickSort(arr, 0, arr.size() - 1);",
            "    end = omp_get_wtime();",
            "",
            "    cout << \"Quick Sorted Array: \";",
            "    for (auto x : arr) cout << x << \" \";",
            "    cout << \"\\nParallel Time: \" << end - start << \" seconds\\n\";",
            "",
            "    return 0;",
            "}"
        ],
        "description": ""
    }


,
    "MPI Ping Pong": {
        "scope": "java",
        "prefix": "b_ping_mpi",
        "body": [
            "#include <bits/stdc++.h>",
            "#include <mpi.h>",
            "using namespace std;",
            "",
            "int main(int argc, char** argv) {",
            "    MPI_Init(&argc, &argv);",
            "",
            "    int rank, size;",
            "    MPI_Comm_rank(MPI_COMM_WORLD, &rank);",
            "    MPI_Comm_size(MPI_COMM_WORLD, &size);",
            "",
            "    if (size % 2 != 0) {",
            "        if(rank == 0) cout << \"Please run with an even number of processes.\\n\";",
            "        MPI_Finalize();",
            "        return 0;",
            "    }",
            "",
            "    int partner = (rank % 2 == 0) ? rank + 1 : rank - 1;",
            "    int rounds = 5;",
            "    int msg = 0;",
            "",
            "    for (int r = 1; r <= rounds; r++) {",
            "        if (rank % 2 == 0) {",
            "            msg = r;",
            "            MPI_Send(&msg, 1, MPI_INT, partner, 0, MPI_COMM_WORLD);",
            "            cout << \"Round \" << r << \": Process \" << rank << \" send ping = \" << msg << endl;",
            "            MPI_Recv(&msg, 1, MPI_INT, partner, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);",
            "            cout << \"Round \" << r << \": Process \" << rank << \" received pong = \" << msg << endl;",
            "        } else {",
            "            MPI_Recv(&msg, 1, MPI_INT, partner, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);",
            "            cout << \"Round \" << r << \": Process \" << rank << \" received ping = \" << msg << endl;",
            "            msg = r;",
            "            MPI_Send(&msg, 1, MPI_INT, partner, 0, MPI_COMM_WORLD);",
            "            cout << \"Round \" << r << \": Process \" << rank << \" send ping = \" << msg << endl;",
            "        }",
            "    }",
            "",
            "    MPI_Finalize();",
            "    return 0;",
            "}"
        ],
        "description": ""
    }
,
    "MPI Local Sum Global": {
        "scope": "java",
        "prefix": "b_localsum_mpi",
        "body": [
            "#include <mpi.h>",
            "#include <iostream>",
            "#include <cstdlib>",
            "#include <ctime>",
            "using namespace std;",
            "",
            "int main(int argc, char* argv[]) {",
            "    MPI_Init(&argc, &argv);",
            "",
            "    int rank, size;",
            "    MPI_Comm_rank(MPI_COMM_WORLD, &rank);",
            "    MPI_Comm_size(MPI_COMM_WORLD, &size);",
            "",
            "    srand(time(0) + rank);",
            "    int local_num = rand() % 100;",
            "    cout << \"Process \" << rank << \" generated: \" << local_num << endl;",
            "",
            "    int global_sum;",
            "    MPI_Reduce(&local_num, &global_sum, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);",
            "",
            "    if(rank == 0) cout << \"Global sum at rank 0: \" << global_sum << endl;",
            "",
            "    MPI_Bcast(&global_sum, 1, MPI_INT, 0, MPI_COMM_WORLD);",
            "    cout << \"Process \" << rank << \" received sum: \" << global_sum << endl;",
            "",
            "    MPI_Finalize();",
            "    return 0;",
            "}"
        ],
        "description": ""
    }
,
    "MPI All-to-All": {
        "scope": "java",
        "prefix": "b_alltoall_mpi",
        "body": [
            "#include <mpi.h>",
            "#include <iostream>",
            "using namespace std;",
            "",
            "int main(int argc, char** argv) {",
            "    MPI_Init(&argc, &argv);",
            "",
            "    int rank, size;",
            "    MPI_Comm_rank(MPI_COMM_WORLD, &rank);",
            "    MPI_Comm_size(MPI_COMM_WORLD, &size);",
            "",
            "    int send_data[size];",
            "    for (int i = 0; i < size; i++)",
            "        send_data[i] = rank * 10 + i;",
            "",
            "    int recv_data[size];",
            "",
            "    MPI_Alltoall(send_data, 1, MPI_INT, recv_data, 1, MPI_INT, MPI_COMM_WORLD);",
            "",
            "    cout << \"Process \" << rank << \" send: \";",
            "    for (int i = 0; i < size; i++)",
            "        cout << send_data[i] << \" \";",
            "    cout << endl;",
            "    MPI_Barrier(MPI_COMM_WORLD);",
            "",
            "    cout << \"Process \" << rank << \" received: \";",
            "    for (int i = 0; i < size; i++)",
            "        cout << recv_data[i] << \" \";",
            "    cout << endl;",
            "",
            "    MPI_Finalize();",
            "    return 0;",
            "}"
        ],
        "description": ""
    }
,
    "MPI Allgather": {
        "scope": "java",
        "prefix": "b_allgather_mpi",
        "body": [
            "#include <mpi.h>",
            "#include <iostream>",
            "#include <cstring>",
            "using namespace std;",
            "",
            "int main(int argc, char** argv) {",
            "    MPI_Init(&argc, &argv);",
            "",
            "    int rank, size;",
            "    MPI_Comm_rank(MPI_COMM_WORLD, &rank);",
            "    MPI_Comm_size(MPI_COMM_WORLD, &size);",
            "",
            "    string local_str(rank + 1, 'A' + rank);",
            "",
            "    int local_len = local_str.length();",
            "    int recv_counts[size], displs[size];",
            "",
            "    MPI_Allgather(&local_len, 1, MPI_INT, recv_counts, 1, MPI_INT, MPI_COMM_WORLD);",
            "",
            "    int total_len = 0;",
            "    for (int i = 0; i < size; i++) {",
            "        displs[i] = total_len;",
            "        total_len += recv_counts[i];",
            "    }",
            "",
            "    char recv_buffer[100];",
            "    MPI_Allgatherv(local_str.c_str(), local_len, MPI_CHAR,",
            "                   recv_buffer, recv_counts, displs, MPI_CHAR, MPI_COMM_WORLD);",
            "",
            "    recv_buffer[total_len] = '\\0';",
            "    cout << \"Process \" << rank << \" collected: \" << recv_buffer << endl;",
            "",
            "    MPI_Finalize();",
            "    return 0;",
            "}"
        ],
        "description": ""
    }
,
    "MPI Trapezoidal Integration": {
        "scope": "java",
        "prefix": "b_trapezoid_mpi",
        "body": [
            "#include <bits/stdc++.h>",
            "#include <mpi.h>",
            "#include <omp.h>",
            "using namespace std;",
            "",
            "double f(double x) {",
            "    return x * x;",
            "}",
            "",
            "int main(int argc, char** argv) {",
            "    MPI_Init(&argc, &argv);",
            "    int rank, size;",
            "    MPI_Comm_rank(MPI_COMM_WORLD, &rank);",
            "    MPI_Comm_size(MPI_COMM_WORLD, &size);",
            "",
            "    double a = 0.0, b = 10.0;",
            "    long long n = 100000000;",
            "    double h = (b - a) / n;",
            "    long long local_n = n / size;",
            "    double local_a = a + rank * local_n * h;",
            "    double local_b = local_a + local_n * h;",
            "",
            "    double local_sum = 0.0;",
            "    #pragma omp parallel",
            "    {",
            "        double x, sum = 0.0;",
            "        #pragma omp for",
            "        for (long long i = 0; i < local_n; i++) {",
            "            x = local_a + i * h;",
            "            sum += (f(x) + f(x + h)) / 2.0;",
            "        }",
            "        #pragma omp atomic",
            "        local_sum += sum;",
            "    }",
            "",
            "    local_sum *= h;",
            "    double total_sum = 0.0;",
            "    MPI_Reduce(&local_sum, &total_sum, 1, MPI_DOUBLE, MPI_SUM, 0, MPI_COMM_WORLD);",
            "",
            "    if (rank == 0) {",
            "        cout << \"Integral from \" << a << \" to \" << b << \" = \" << total_sum << endl;",
            "    }",
            "",
            "    MPI_Finalize();",
            "    return 0;",
            "}"
        ],
        "description": ""
    }
,
    "OpenMP Gaussian Elimination": {
        "scope": "java",
        "prefix": "b_gauss_omp",
        "body": [
            "#include <bits/stdc++.h>",
            "#include <omp.h>",
            "using namespace std;",
            "",
            "void gaussElimination(vector<vector<double>>& A, vector<double>& b, vector<double>& x, int n) {",
            "    for(int k = 0; k < n - 1; k++) {",
            "        #pragma omp parallel for",
            "        for(int i = k + 1; i < n; i++) {",
            "            double factor = A[i][k] / A[k][k];",
            "            for(int j = k; j < n; j++)",
            "                A[i][j] -= factor * A[k][j];",
            "            b[i] -= factor * b[k];",
            "        }",
            "    }",
            "",
            "    for(int i = n - 1; i >= 0; i--) {",
            "        x[i] = b[i];",
            "        for(int j = i + 1; j < n; j++)",
            "            x[i] -= A[i][j] * x[j];",
            "        x[i] /= A[i][i];",
            "    }",
            "}",
            "",
            "int main() {",
            "    int n = 3;",
            "    vector<vector<double>> A = {",
            "        {2, -1, 1},",
            "        {3, 3, 9},",
            "        {3, 3, 5}",
            "    };",
            "    vector<double> b = {2, -1, 4};",
            "    vector<double> x(n);",
            "",
            "    vector<int> threads = {1, 2, 4, 6};",
            "    for(int t : threads) {",
            "        vector<vector<double>> At = A;",
            "        vector<double> bt = b;",
            "",
            "        omp_set_num_threads(t);",
            "        double start = omp_get_wtime();",
            "        gaussElimination(At, bt, x, n);",
            "        double end = omp_get_wtime();",
            "",
            "        cout << \"Threads: \" << t << \" | Time: \" << fixed << setprecision(6) << end - start << \" sec\" << endl;",
            "    }",
            "",
            "    cout << \"Solution (last run): \";",
            "    for(int i = 0; i < n; i++) cout << x[i] << \" \";",
            "    cout << endl;",
            "",
            "    return 0;",
            "}"
        ],
        "description": ""
    }
,
    "MPI Matrix Multiplication": {
        "scope": "java",
        "prefix": "b_matrix_mpi",
        "body": [
            "#include <iostream>",
            "#include <mpi.h>",
            "using namespace std;",
            "",
            "int main(int argc, char** argv) {",
            "    MPI_Init(&argc, &argv);",
            "",
            "    int rank, size;",
            "    MPI_Comm_rank(MPI_COMM_WORLD, &rank);",
            "    MPI_Comm_size(MPI_COMM_WORLD, &size);",
            "",
            "    const int N = 3;",
            "    int A[N][N] = { {1, 2, 3},",
            "                    {4, 5, 6},",
            "                    {7, 8, 9} };",
            "",
            "    int B[N][N] = { {9, 8, 7},",
            "                    {6, 5, 4},",
            "                    {3, 2, 1} };",
            "",
            "    int C[N][N] = {0};",
            "",
            "    MPI_Bcast(B, N * N, MPI_INT, 0, MPI_COMM_WORLD);",
            "",
            "    int local_n = N / size;",
            "    int local_A[local_n][N];",
            "    MPI_Scatter(A, local_n * N, MPI_INT, local_A, local_n * N, MPI_INT, 0, MPI_COMM_WORLD);",
            "",
            "    int local_C[local_n][N] = {0};",
            "    for (int i = 0; i < local_n; i++) {",
            "        for (int j = 0; j < N; j++) {",
            "            for (int k = 0; k < N; k++) {",
            "                local_C[i][j] += local_A[i][k] * B[k][j];",
            "            }",
            "        }",
            "    }",
            "",
            "    MPI_Gather(local_C, local_n * N, MPI_INT, C, local_n * N, MPI_INT, 0, MPI_COMM_WORLD);",
            "",
            "    if (rank == 0) {",
            "        cout << \"\\nResultant Matrix C = A * B:\\n\";",
            "        for (int i = 0; i < N; i++) {",
            "            for (int j = 0; j < N; j++)",
            "                cout << C[i][j] << \" \";",
            "            cout << endl;",
            "        }",
            "    }",
            "",
            "    MPI_Finalize();",
            "    return 0;",
            "}"
        ],
        "description": ""
    }
,
    "LU Factorization with OpenMP": {
        "prefix": "b_LU_liner",
        "scope": "java",
        "body": [
            "#include <bits/stdc++.h>",
            "#include <omp.h>",
            "using namespace std;",
            "",
            "#define N 3",
            "",
            "void printMatrix(double M[N][N], const string &name) {",
            "    cout << name << \" = \\n\";",
            "    for (int i = 0; i < N; i++) {",
            "        for (int j = 0; j < N; j++)",
            "            cout << setw(8) << fixed << setprecision(4) << M[i][j] << \" \";",
            "        cout << endl;",
            "    }",
            "    cout << endl;",
            "}",
            "",
            "int main() {",
            "    // Example system: A * x = b",
            "    // 2x1 + 3x2 + x3 = 1",
            "    // 4x1 + 4x2 - 3x3 = 4",
            "    // -2x1 + 3x2 + 2x3 = 5",
            "",
            "    double A[N][N] = {",
            "        {2, 3, 1},",
            "        {4, 4, -3},",
            "        {-2, 3, 2}",
            "    };",
            "    double b[N] = {1, 4, 5};",
            "    double L[N][N] = {0}, U[N][N] = {0};",
            "",
            "    double start = omp_get_wtime();",
            "",
            "    // --- LU Factorization ---",
            "    for (int i = 0; i < N; i++) {",
            "        // Compute U matrix",
            "        #pragma omp parallel for",
            "        for (int j = i; j < N; j++) {",
            "            double sum = 0.0;",
            "            for (int k = 0; k < i; k++)",
            "                sum += L[i][k] * U[k][j];",
            "            U[i][j] = A[i][j] - sum;",
            "        }",
            "",
            "        // Compute L matrix",
            "        #pragma omp parallel for",
            "        for (int j = i; j < N; j++) {",
            "            if (i == j)",
            "                L[i][i] = 1.0;",
            "            else {",
            "                double sum = 0.0;",
            "                for (int k = 0; k < i; k++)",
            "                    sum += L[j][k] * U[k][i];",
            "                L[j][i] = (A[j][i] - sum) / U[i][i];",
            "            }",
            "        }",
            "    }",
            "",
            "    double end = omp_get_wtime();",
            "",
            "    // --- Forward substitution: L * y = b ---",
            "    double y[N];",
            "    for (int i = 0; i < N; i++) {",
            "        double sum = 0.0;",
            "        for (int j = 0; j < i; j++)",
            "            sum += L[i][j] * y[j];",
            "        y[i] = b[i] - sum;",
            "    }",
            "",
            "    // --- Backward substitution: U * x = y ---",
            "    double x[N];",
            "    for (int i = N - 1; i >= 0; i--) {",
            "        double sum = 0.0;",
            "        for (int j = i + 1; j < N; j++)",
            "            sum += U[i][j] * x[j];",
            "        x[i] = (y[i] - sum) / U[i][i];",
            "    }",
            "",
            "    // --- Output ---",
            "    printMatrix(L, \"L\");",
            "    printMatrix(U, \"U\");",
            "",
            "    cout << \"Solution (x1, x2, x3):\\n\";",
            "    for (int i = 0; i < N; i++)",
            "        cout << \"x\" << i + 1 << \" = \" << fixed << setprecision(4) << x[i] << endl;",
            "",
            "    cout << \"\\nExecution Time = \" << end - start << \" seconds\\n\";",
            "    return 0;",
            "}"
        ],
        "description": ""
    }
,
    "Floyd Warshall MPI Program": {
        "prefix": "b_floyd_mpi",
        "body": [
            "#include <bits/stdc++.h>",
            "#include <mpi.h>",
            "using namespace std;",
            "",
            "#define INF 9999",
            "#define N 4   // number of vertices",
            "",
            "int main(int argc, char* argv[]) {",
            "    int rank, size;",
            "    MPI_Init(&argc, &argv);",
            "    MPI_Comm_rank(MPI_COMM_WORLD, &rank);",
            "    MPI_Comm_size(MPI_COMM_WORLD, &size);",
            "",
            "    // Graph adjacency matrix (INF = no direct edge)",
            "    int dist[N][N] = {",
            "        {0,   3,   INF, 7},",
            "        {8,   0,   2,   INF},",
            "        {5,   INF, 0,   1},",
            "        {2,   INF, INF, 0}",
            "    };",
            "",
            "    int rows_per_proc = N / size;           // divide rows equally",
            "    int start = rank * rows_per_proc;",
            "    int end = (rank == size - 1) ? N : start + rows_per_proc;",
            "",
            "    // Main Floyd-Warshall loop",
            "    for (int k = 0; k < N; k++) {",
            "        // Broadcast the k-th row to all processes",
            "        MPI_Bcast(dist[k], N, MPI_INT, k / rows_per_proc, MPI_COMM_WORLD);",
            "",
            "        // Update only this process's rows",
            "        for (int i = start; i < end; i++) {",
            "            for (int j = 0; j < N; j++) {",
            "                if (dist[i][k] + dist[k][j] < dist[i][j])",
            "                    dist[i][j] = dist[i][k] + dist[k][j];",
            "            }",
            "        }",
            "",
            "        // Share updated rows across all processes",
            "        for (int i = 0; i < size; i++) {",
            "            int row_start = i * rows_per_proc;",
            "            int row_end = (i == size - 1) ? N : row_start + rows_per_proc;",
            "            MPI_Bcast(&dist[row_start][0], (row_end - row_start) * N, MPI_INT, i, MPI_COMM_WORLD);",
            "        }",
            "    }",
            "",
            "    // Gather final matrix on process 0",
            "    if (rank == 0) {",
            "        cout << \"\\\\nAll Pairs Shortest Path Matrix:\\\\n\";",
            "        for (int i = 0; i < N; i++) {",
            "            for (int j = 0; j < N; j++) {",
            "                if (dist[i][j] == INF)",
            "                    cout << \"INF \";",
            "                else",
            "                    cout << dist[i][j] << \" \";",
            "            }",
            "            cout << endl;",
            "        }",
            "    }",
            "",
            "    MPI_Finalize();",
            "    return 0;",
            "}"
        ],
        "description": ""
    }
,
    "Jacobi Method MPI Program": {
        "prefix": "b_jacobi_mpi",
        "body": [
            "#include <iostream>",
            "#include <mpi.h>",
            "using namespace std;",
            "",
            "int main(int argc, char* argv[]) {",
            "    int rank, size;",
            "    MPI_Init(&argc, &argv);",
            "    MPI_Comm_rank(MPI_COMM_WORLD, &rank);",
            "    MPI_Comm_size(MPI_COMM_WORLD, &size);",
            "",
            "    // 3x3 system",
            "    double a[3][3] = {{4, 1, 1},",
            "                      {1, 5, 2},",
            "                      {2, 3, 10}};",
            "    double b[3] = {7, -8, 6};",
            "",
            "    double x_old[3] = {0, 0, 0}; // initial guess",
            "    double x_new[3];",
            "    int max_iter = 10;",
            "",
            "    for (int k = 0; k < max_iter; k++) {",
            "        if (rank == 0) { // compute x1",
            "            x_new[0] = (b[0] - a[0][1] * x_old[1] - a[0][2] * x_old[2]) / a[0][0];",
            "        }",
            "        if (rank == 1) { // compute x2",
            "            x_new[1] = (b[1] - a[1][0] * x_old[0] - a[1][2] * x_old[2]) / a[1][1];",
            "        }",
            "        if (rank == 2) { // compute x3",
            "            x_new[2] = (b[2] - a[2][0] * x_old[0] - a[2][1] * x_old[1]) / a[2][2];",
            "        }",
            "",
            "        // share all updated x values with all processes",
            "        MPI_Allgather(MPI_IN_PLACE, 0, MPI_DATATYPE_NULL,",
            "                      x_new, 1, MPI_DOUBLE, MPI_COMM_WORLD);",
            "",
            "        // update x_old for next iteration",
            "        for (int i = 0; i < 3; i++)",
            "            x_old[i] = x_new[i];",
            "",
            "        if (rank == 0)",
            "            cout << \"Iter \" << k + 1 << \": x1=\" << x_new[0]",
            "                 << \", x2=\" << x_new[1] << \", x3=\" << x_new[2] << endl;",
            "    }",
            "",
            "    MPI_Finalize();",
            "    return 0;",
            "}"
        ],
        "description": ""
    }
,
    "Jacobi Method OpenMP Program": {
        "prefix": "b_jacobi_omp",
        "body": [
            "#include <iostream>",
            "#include <omp.h>",
            "using namespace std;",
            "",
            "int main() {",
            "    double a[3][3] = {{4, 1, 1},",
            "                      {1, 5, 2},",
            "                      {2, 3, 10}};",
            "    double b[3] = {7, -8, 6};",
            "    double x_old[3] = {0, 0, 0};",
            "    double x_new[3] = {0, 0, 0};",
            "    int max_iter = 10;",
            "",
            "    for (int iter = 0; iter < max_iter; iter++) {",
            "        // Each thread updates one element independently",
            "        #pragma omp parallel for",
            "        for (int i = 0; i < 3; i++) {",
            "            double sum = b[i];",
            "            for (int j = 0; j < 3; j++) {",
            "                if (i != j)",
            "                    sum -= a[i][j] * x_old[j];",
            "            }",
            "            x_new[i] = sum / a[i][i];",
            "        }",
            "",
            "        // Copy x_new to x_old for next iteration",
            "        for (int i = 0; i < 3; i++)",
            "            x_old[i] = x_new[i];",
            "",
            "        cout << \"Iter \" << iter + 1 << \": x1=\" << x_new[0]",
            "             << \", x2=\" << x_new[1] << \", x3=\" << x_new[2] << endl;",
            "    }",
            "",
            "    return 0;",
            "}"
        ],
        "description": ""
    }
,
    "GaussSeidel MPI Program": {
        "prefix": "b_gauss_seidel_mpi",
        "body": [
            "#include <iostream>",
            "#include <mpi.h>",
            "using namespace std;",
            "",
            "int main(int argc, char* argv[]) {",
            "    int rank, size;",
            "    MPI_Init(&argc, &argv);",
            "    MPI_Comm_rank(MPI_COMM_WORLD, &rank);",
            "    MPI_Comm_size(MPI_COMM_WORLD, &size);",
            "",
            "    double a[3][3] = {{4, 1, 1},",
            "                      {1, 5, 2},",
            "                      {2, 3, 10}};",
            "    double b[3] = {7, -8, 6};",
            "    double x[3] = {0, 0, 0};",
            "    int max_iter = 10;",
            "",
            "    for (int k = 0; k < max_iter; k++) {",
            "        if (rank == 0) {",
            "            x[0] = (b[0] - a[0][1] * x[1] - a[0][2] * x[2]) / a[0][0];",
            "        }",
            "        MPI_Bcast(&x[0], 1, MPI_DOUBLE, 0, MPI_COMM_WORLD); // share x1",
            "",
            "        if (rank == 1) {",
            "            x[1] = (b[1] - a[1][0] * x[0] - a[1][2] * x[2]) / a[1][1];",
            "        }",
            "        MPI_Bcast(&x[1], 1, MPI_DOUBLE, 1, MPI_COMM_WORLD); // share x2",
            "",
            "        if (rank == 2) {",
            "            x[2] = (b[2] - a[2][0] * x[0] - a[2][1] * x[1]) / a[2][2];",
            "        }",
            "        MPI_Bcast(&x[2], 1, MPI_DOUBLE, 2, MPI_COMM_WORLD); // share x3",
            "",
            "        if (rank == 0)",
            "            cout << \"Iter \" << k + 1 << \": x1=\" << x[0]",
            "                 << \", x2=\" << x[1] << \", x3=\" << x[2] << endl;",
            "    }",
            "",
            "    MPI_Finalize();",
            "    return 0;",
            "}"
        ],
        "description": ""
    }
,
  "GaussSeidelOpenMP": {
    "prefix": "b_gaussseidel_omp",
    "body": [
      "#include <iostream>",
      "#include <omp.h>",
      "using namespace std;",
      "",
      "int main() {",
      "    double a[3][3] = {",
      "        {4, 1, 1},",
      "        {1, 5, 2},",
      "        {2, 3, 10}",
      "    };",
      "    double b[3] = {7, -8, 6};",
      "    double x[3] = {0, 0, 0};",
      "    int max_iter = 10;",
      "",
      "    cout << \"Gauss-Seidel Method using OpenMP\\\\n\";",
      "",
      "    for (int iter = 0; iter < max_iter; iter++) {",
      "        for (int i = 0; i < 3; i++) {",
      "            double sum = b[i];",
      "            for (int j = 0; j < 3; j++) {",
      "                if (i != j)",
      "                    sum -= a[i][j] * x[j];",
      "            }",
      "            x[i] = sum / a[i][i];",
      "        }",
      "",
      "        #pragma omp single",
      "        {",
      "            cout << \"Iteration \" << iter + 1 << \": \"",
      "                 << \"x1 = \" << x[0]",
      "                 << \", x2 = \" << x[1]",
      "                 << \", x3 = \" << x[2] << endl;",
      "        }",
      "    }",
      "",
      "    cout << \"\\\\nFinal Solution:\\\\n\";",
      "    cout << \"x1 = \" << x[0] << \"\\\\n\";",
      "    cout << \"x2 = \" << x[1] << \"\\\\n\";",
      "    cout << \"x3 = \" << x[2] << \"\\\\n\";",
      "",
      "    return 0;",
      "}"
    ],
    "description": ""
  }
}















